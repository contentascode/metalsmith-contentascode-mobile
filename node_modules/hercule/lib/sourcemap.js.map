{"version":3,"sources":["../src/sourcemap.js"],"names":["SourceMapStream","updateCursor","cursor","content","currentLine","line","currentColumn","column","newLines","match","length","newColumns","generatedFile","mappings","transform","chunk","encoding","cb","originalLocation","push","source","relative","dirname","original","generated","flush","generator","SourceMapGenerator","file","__dirname","forEach","addMapping","map","emit","JSON","parse","toString","obj"],"mappings":";;;;;kBAmBwBA,e;;AAnBxB;;;;AAEA;;;;AACA;;;;AACA;;;;;;AAEA,SAASC,YAAT,CAAsBC,MAAtB,EAA8BC,OAA9B,EAAuC;AACrC,MAAMC,cAAcF,OAAOG,IAA3B;AACA,MAAMC,gBAAgBJ,OAAOK,MAA7B;;AAEA,MAAMC,WAAW,CAACL,QAAQM,KAAR,CAAc,KAAd,KAAwB,EAAzB,EAA6BC,MAA9C;AACA,MAAMC,aAAa,CAACR,QAAQM,KAAR,CAAc,MAAd,KAAyB,CAAC,EAAD,CAA1B,EAAgC,CAAhC,EAAmCC,MAAtD;;AAEA,MAAML,OAAOD,cAAcI,QAA3B;AACA,MAAMD,SAASC,WAAW,CAAX,GAAeG,UAAf,GAA4BL,gBAAgBK,UAA3D;;AAEA,SAAO,EAAEN,UAAF,EAAQE,cAAR,EAAP;AACD;;AAEc,SAASP,eAAT,GAAmD;AAAA,MAA1BY,aAA0B,uEAAV,QAAU;;AAChE,MAAMC,WAAW,EAAjB;AACA,MAAIX,SAAS;AACXG,UAAM,CADK;AAEXE,YAAQ;AAFG,GAAb;;AAKA,WAASO,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCC,EAApC,EAAwC;AACtC,QAAMd,UAAUY,MAAMZ,OAAtB;AACA,QAAMe,mBAAmB,EAAEb,MAAMU,MAAMV,IAAd,EAAoBE,QAAQQ,MAAMR,MAAlC,EAAzB;;AAEA,QAAIJ,YAAY,EAAhB,EAAoB,OAAOc,IAAP;AACpB,QAAI,CAACL,aAAL,EAAoB,OAAOK,IAAP;;AAEpBJ,aAASM,IAAT,CAAc;AACZC,cAAQ,eAAKC,QAAL,CAAc,eAAKC,OAAL,CAAaV,aAAb,CAAd,EAA2CG,MAAMK,MAAjD,CADI;AAEZG,gBAAUL,gBAFE;AAGZM,iBAAWtB;AAHC,KAAd;AAKAA,aAASD,aAAaC,MAAb,EAAqBC,OAArB,CAAT;;AAEA,SAAKgB,IAAL,CAAUJ,KAAV;AACA,WAAOE,IAAP;AACD;;AAED,WAASQ,KAAT,CAAeR,EAAf,EAAmB;AACjB,QAAI,CAACL,aAAL,EAAoB,OAAOK,IAAP;;AAEpB,QAAMS,YAAY,IAAI,oBAAUC,kBAAd,CAAiC,EAAEC,MAAM,eAAKP,QAAL,CAAcQ,SAAd,EAAyBjB,aAAzB,CAAR,EAAjC,CAAlB;AACA,qBAAEkB,OAAF,CAAUjB,QAAV,EAAoB;AAAA,aAAOa,UAAUK,UAAV,CAAqBC,GAArB,CAAP;AAAA,KAApB;AACA,SAAKC,IAAL,CAAU,WAAV,EAAuBC,KAAKC,KAAL,CAAWT,UAAUU,QAAV,EAAX,CAAvB;AACA,WAAOnB,IAAP;AACD;;AAED,SAAO,kBAASoB,GAAT,CAAavB,SAAb,EAAwBW,KAAxB,CAAP;AACD","file":"sourcemap.js","sourcesContent":["import path from 'path';\n\nimport _ from 'lodash';\nimport through2 from 'through2';\nimport sourceMap from 'source-map';\n\nfunction updateCursor(cursor, content) {\n  const currentLine = cursor.line;\n  const currentColumn = cursor.column;\n\n  const newLines = (content.match(/\\n/g) || []).length;\n  const newColumns = (content.match(/.*$/g) || [''])[0].length;\n\n  const line = currentLine + newLines;\n  const column = newLines > 0 ? newColumns : currentColumn + newColumns;\n\n  return { line, column };\n}\n\nexport default function SourceMapStream(generatedFile = 'string') {\n  const mappings = [];\n  let cursor = {\n    line: 1,\n    column: 0,\n  };\n\n  function transform(chunk, encoding, cb) {\n    const content = chunk.content;\n    const originalLocation = { line: chunk.line, column: chunk.column };\n\n    if (content === '') return cb();\n    if (!generatedFile) return cb();\n\n    mappings.push({\n      source: path.relative(path.dirname(generatedFile), chunk.source),\n      original: originalLocation,\n      generated: cursor,\n    });\n    cursor = updateCursor(cursor, content);\n\n    this.push(chunk);\n    return cb();\n  }\n\n  function flush(cb) {\n    if (!generatedFile) return cb();\n\n    const generator = new sourceMap.SourceMapGenerator({ file: path.relative(__dirname, generatedFile) });\n    _.forEach(mappings, map => generator.addMapping(map));\n    this.emit('sourcemap', JSON.parse(generator.toString()));\n    return cb();\n  }\n\n  return through2.obj(transform, flush);\n}\n"]}