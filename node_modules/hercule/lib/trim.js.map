{"version":3,"sources":["../src/trim.js"],"names":["Trim","NEWLINE","inputBuffer","memoContent","memoSource","transform","chunk","encoding","cb","content","push","length","nextFileIsAncestor","parents","includes","source","isFileEdge","slice","pop","out","shift","flush","obj"],"mappings":";;;;;kBAGwBA,I;;AAHxB;;;;AACA;;;;;;AAEe,SAASA,IAAT,GAAgB;AAC7B,MAAMC,UAAU,IAAhB;AACA,MAAMC,cAAc,EAApB;AACA,MAAIC,cAAc,IAAlB;AACA,MAAIC,aAAa,IAAjB;;AAEA,WAASC,SAAT,CAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCC,EAApC,EAAwC;AACtC,QAAIF,MAAMG,OAAN,KAAkB,EAAtB,EAA0B,OAAOD,IAAP;;AAE1BN,gBAAYQ,IAAZ,CAAiBJ,KAAjB;;AAEA,WAAOJ,YAAYS,MAAZ,GAAqB,CAA5B,EAA+B;AAC7B,UAAMC,qBAAqBV,YAAY,CAAZ,EAAeW,OAAf,IAA0B,iBAAEC,QAAF,CAAWZ,YAAY,CAAZ,EAAeW,OAA1B,EAAmCX,YAAY,CAAZ,EAAea,MAAlD,CAArD;AACA,UAAMC,aAAad,YAAY,CAAZ,EAAea,MAAf,KAA0Bb,YAAY,CAAZ,EAAea,MAAzC,IAAmDX,eAAeF,YAAY,CAAZ,EAAea,MAApG;;AAEA;AACA,UAAIC,cAAcJ,kBAAlB,EAAsC;AACpC,YAAI,CAACV,YAAY,CAAZ,EAAeO,OAAf,CAAuBQ,KAAvB,CAA6B,CAAC,CAA9B,MAAqChB,OAArC,IAAgDE,gBAAgBF,OAAjE,KACJC,YAAY,CAAZ,EAAeO,OAAf,CAAuBQ,KAAvB,CAA6B,CAA7B,EAAgC,CAAhC,MAAuChB,OADvC,EACgD;AAC9C;AACA;AACA;AACAC,sBAAY,CAAZ,EAAeO,OAAf,GAAyBP,YAAY,CAAZ,EAAeO,OAAf,CAAuBQ,KAAvB,CAA6B,CAA7B,CAAzB;AACAd,wBAAcF,OAAd;AACAG,uBAAaF,YAAY,CAAZ,EAAea,MAA5B;;AAEA,cAAIb,YAAY,CAAZ,EAAeO,OAAf,KAA2B,EAA/B,EAAmC;AACjC;AACA;AACAP,wBAAYgB,GAAZ;AACD;AACF,SAdD,MAcO,IAAI,CAAChB,YAAY,CAAZ,EAAeO,OAAf,CAAuBQ,KAAvB,CAA6B,CAAC,CAA9B,MAAqChB,OAArC,IAAgDE,gBAAgBF,OAAjE,KACXC,YAAY,CAAZ,EAAeO,OAAf,CAAuBQ,KAAvB,CAA6B,CAA7B,EAAgC,CAAhC,MAAuChB,OADhC,EACyC;AAC9C;AACA;AACAC,sBAAY,CAAZ,EAAeO,OAAf,GAAyBP,YAAY,CAAZ,EAAeO,OAAf,CAAuBQ,KAAvB,CAA6B,CAA7B,EAAgC,CAAC,CAAjC,CAAzB;AACAd,wBAAc,IAAd;AACAC,uBAAa,IAAb;AACD;AACF,OAvBD,MAuBO;AACLD,sBAAc,IAAd;AACAC,qBAAa,IAAb;AACD;;AAED,UAAIF,YAAYS,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,YAAMQ,MAAMjB,YAAYkB,KAAZ,EAAZ;AACA,aAAKV,IAAL,CAAUS,GAAV;AACD;AACF;;AAED,WAAOX,IAAP;AACD;;AAED,WAASa,KAAT,CAAeb,EAAf,EAAmB;AACjB;AACA,QAAIN,YAAYS,MAAZ,GAAqB,CAAzB,EAA4B,KAAKD,IAAL,CAAUR,YAAYkB,KAAZ,EAAV;AAC5B,SAAKV,IAAL,CAAU,IAAV;AACA,WAAOF,IAAP;AACD;;AAED,SAAO,kBAASc,GAAT,CAAajB,SAAb,EAAwBgB,KAAxB,CAAP;AACD","file":"trim.js","sourcesContent":["import _ from 'lodash';\nimport through2 from 'through2';\n\nexport default function Trim() {\n  const NEWLINE = '\\n';\n  const inputBuffer = [];\n  let memoContent = null;\n  let memoSource = null;\n\n  function transform(chunk, encoding, cb) {\n    if (chunk.content === '') return cb();\n\n    inputBuffer.push(chunk);\n\n    while (inputBuffer.length > 1) {\n      const nextFileIsAncestor = inputBuffer[1].parents && _.includes(inputBuffer[0].parents, inputBuffer[1].source);\n      const isFileEdge = inputBuffer[0].source !== inputBuffer[1].source && memoSource !== inputBuffer[1].source;\n\n      // EOF edge verify file is ending checking it isn't a parent of the next file\n      if (isFileEdge && nextFileIsAncestor) {\n        if ((inputBuffer[0].content.slice(-1) === NEWLINE || memoContent === NEWLINE) &&\n        inputBuffer[1].content.slice(0, 1) === NEWLINE) {\n          // Scenario A: transclusion at end of line since both characters are a new line\n          //    remove new line from next file\n          //    Edge: still be inline, can't yet push\n          inputBuffer[1].content = inputBuffer[1].content.slice(1);\n          memoContent = NEWLINE;\n          memoSource = inputBuffer[1].source;\n\n          if (inputBuffer[1].content === '') {\n            // The token was only one character long.\n            // The removed new line could either be EOF or mid-file\n            inputBuffer.pop();\n          }\n        } else if ((inputBuffer[0].content.slice(-1) === NEWLINE || memoContent === NEWLINE) &&\n        inputBuffer[1].content.slice(0, 1) !== NEWLINE) {\n          // Scenario B: inline transclusion since next character is not a new line\n          //   remove new line from end of file\n          inputBuffer[0].content = inputBuffer[0].content.slice(0, -1);\n          memoContent = null;\n          memoSource = null;\n        }\n      } else {\n        memoContent = null;\n        memoSource = null;\n      }\n\n      if (inputBuffer.length > 1) {\n        const out = inputBuffer.shift();\n        this.push(out);\n      }\n    }\n\n    return cb();\n  }\n\n  function flush(cb) {\n    // Empty internal buffer and signal the end of the output stream.\n    if (inputBuffer.length > 0) this.push(inputBuffer.shift());\n    this.push(null);\n    return cb();\n  }\n\n  return through2.obj(transform, flush);\n}\n"]}