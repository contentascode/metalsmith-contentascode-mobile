{"version":3,"sources":["../src/main.js"],"names":["cli","string","boolean","default","syntax","relative","alias","o","s","r","m","h","input","length","flags","stdin","process","stderr","write","showHelp","inputStream","source","options","transclusionSyntax","normalize","createReadStream","encoding","join","outputStream","output","createWriteStream","stdout","outputFile","transclude","on","err","message","path","exit","sourcemap","sourcemapFilepath","writeFileSync","JSON","stringify","pipe"],"mappings":";;AAMA;;;;AACA;;;;AACA;;;;AACA;;;;AATA;;;;;;AAWA,IAAMA,MAAM,oBAAK,CACf,QADe,EAEf,2BAFe,EAGf,EAHe,EAIf,UAJe,EAKf,qEALe,EAMf,qHANe,EAOf,qHAPe,EAQf,gEARe,EASf,sFATe,EAUf,0GAVe,EAWf,EAXe,EAYf,WAZe,EAaf,oBAbe,EAcf,oDAde,EAef,4CAfe,EAgBf,gEAhBe,CAAL,EAiBT;AACDC,UAAQ,CACN,GADM,EAEN,QAFM,EAGN,QAHM,EAIN,UAJM,CADP;AAODC,WAAS,CACP,WADO,EAEP,OAFO,CAPR;AAWDC,WAAS;AACPC,YAAQ,SADD;AAEPC,cAAU;AAFH,GAXR;AAeDC,SAAO;AACLC,OAAG,QADE;AAELC,OAAG,QAFE;AAGLC,OAAG,UAHE;AAILC,OAAG,WAJE;AAKLC,OAAG;AALE;AAfN,CAjBS,CAAZ;;AAyCA,IAAIX,IAAIY,KAAJ,CAAUC,MAAV,KAAqB,CAArB,IAA0B,CAACb,IAAIc,KAAJ,CAAUC,KAAzC,EAAgD;AAC9CC,UAAQC,MAAR,CAAeC,KAAf,CAAqB,yBAArB;AACAlB,MAAImB,QAAJ;AACD;;AAED,IAAIC,oBAAJ;AACA,IAAIC,eAAJ;AACA,IAAMC,UAAU,EAAEC,oBAAoBvB,IAAIc,KAAJ,CAAUV,MAAhC,EAAhB;AACA,IAAMQ,QAAQZ,IAAIY,KAAJ,CAAU,CAAV,CAAd;;AAEA,IAAIA,KAAJ,EAAW;AACT;AACAS,WAAS,eAAKG,SAAL,CAAeZ,KAAf,CAAT;AACAQ,gBAAc,aAAGK,gBAAH,CAAoBJ,MAApB,EAA4B,EAAEK,UAAU,MAAZ,EAA5B,CAAd;AACD,CAJD,MAIO;AACL;AACAL,WAAS,eAAKM,IAAL,CAAU3B,IAAIc,KAAJ,CAAUT,QAApB,EAA8B,OAA9B,CAAT;AACAe,gBAAcJ,QAAQD,KAAtB;AACD;;AAED,IAAMa,eAAe5B,IAAIc,KAAJ,CAAUe,MAAV,GAAmB,aAAGC,iBAAH,CAAqB9B,IAAIc,KAAJ,CAAUe,MAA/B,EAAuC,EAAEH,UAAU,MAAZ,EAAvC,CAAnB,GAAkFV,QAAQe,MAA/G;AACAT,QAAQU,UAAR,GAAqBhC,IAAIc,KAAJ,CAAUe,MAAV,IAAoB,QAAzC;;AAEA,IAAMI,aAAa,8BAAqBZ,MAArB,EAA6BC,OAA7B,CAAnB;;AAEAF,YAAYc,EAAZ,CAAe,OAAf,EAAwB,UAACC,GAAD,EAAS;AAC/BnB,UAAQC,MAAR,CAAeC,KAAf,UAA4BiB,IAAIC,OAAhC,UAA4CD,IAAIE,IAAhD;AACArB,UAAQsB,IAAR,CAAa,CAAb;AACD,CAHD;;AAKAL,WAAWC,EAAX,CAAc,OAAd,EAAuB,UAACC,GAAD,EAAS;AAC9BnB,UAAQC,MAAR,CAAeC,KAAf,iBAAmCiB,IAAIC,OAAvC,UAAmDD,IAAIE,IAAvD;AACArB,UAAQsB,IAAR,CAAa,CAAb;AACD,CAHD;;AAKAL,WAAWC,EAAX,CAAc,WAAd,EAA2B,UAACK,SAAD,EAAe;AACxC,MAAMC,oBAAuBxC,IAAIc,KAAJ,CAAUe,MAAjC,SAAN;AACA,MAAI7B,IAAIc,KAAJ,CAAUyB,SAAV,IAAuBvC,IAAIc,KAAJ,CAAUe,MAArC,EAA6C,aAAGY,aAAH,CAAiBD,iBAAjB,EAAuCE,KAAKC,SAAL,CAAeJ,SAAf,CAAvC;AAC9C,CAHD;;AAKAnB,YAAYwB,IAAZ,CAAiBX,UAAjB,EAA6BW,IAA7B,CAAkChB,YAAlC","file":"main.js","sourcesContent":["/**\n* Hercule\n* A simple markdown transclusion tool\n* Author: James Ramsay\n*/\n\nimport fs from 'fs';\nimport path from 'path';\nimport meow from 'meow';\nimport { TranscludeStream } from './hercule';\n\nconst cli = meow([\n  'Usage:',\n  '  $ hercule [<input> ...]',\n  '',\n  'Options:',\n  '  --stdin, -                 Specifies input to be read from stdin.',\n  '  --output, -o path          Specifies the name and location of the output file.  If not specified, stdout is used.',\n  '  --syntax, -s syntax_name   Specifies which transclusion link syntax (e.g. hercule, aglio, marked, multimarkdown).',\n  '                             If not specifed, hercule is used.',\n  '  --relative, -r path        Specifies the path to which links in input are relative',\n  '  --sourcemap, -m            Specifies a sourcemap should be gnerated. Only used if output is specified.',\n  '',\n  'Examples:',\n  '  $ hercule foo.md',\n  '    Processes the file foo.md and prints to stdout',\n  '  $ cat foo.md | hercule - --output bar.md',\n  '    Processes the input from stdin and writes output to bar.md',\n], {\n  string: [\n    '_',\n    'output',\n    'syntax',\n    'relative',\n  ],\n  boolean: [\n    'sourcemap',\n    'stdin',\n  ],\n  default: {\n    syntax: 'hercule',\n    relative: '',\n  },\n  alias: {\n    o: 'output',\n    s: 'syntax',\n    r: 'relative',\n    m: 'sourcemap',\n    h: 'help',\n  },\n});\n\nif (cli.input.length === 0 && !cli.flags.stdin) {\n  process.stderr.write('\\nNo input specified.\\n');\n  cli.showHelp();\n}\n\nlet inputStream;\nlet source;\nconst options = { transclusionSyntax: cli.flags.syntax };\nconst input = cli.input[0];\n\nif (input) {\n  // Reading input from file\n  source = path.normalize(input);\n  inputStream = fs.createReadStream(source, { encoding: 'utf8' });\n} else {\n  // Reading from stdin\n  source = path.join(cli.flags.relative, 'stdin');\n  inputStream = process.stdin;\n}\n\nconst outputStream = cli.flags.output ? fs.createWriteStream(cli.flags.output, { encoding: 'utf8' }) : process.stdout;\noptions.outputFile = cli.flags.output || 'stdout';\n\nconst transclude = new TranscludeStream(source, options);\n\ninputStream.on('error', (err) => {\n  process.stderr.write(`\\n\\n${err.message} (${err.path})\\n`);\n  process.exit(1);\n});\n\ntransclude.on('error', (err) => {\n  process.stderr.write(`\\n\\nERROR: ${err.message} (${err.path})\\n`);\n  process.exit(1);\n});\n\ntransclude.on('sourcemap', (sourcemap) => {\n  const sourcemapFilepath = `${cli.flags.output}.map`;\n  if (cli.flags.sourcemap && cli.flags.output) fs.writeFileSync(sourcemapFilepath, `${JSON.stringify(sourcemap)}\\n`);\n});\n\ninputStream.pipe(transclude).pipe(outputStream);\n"]}