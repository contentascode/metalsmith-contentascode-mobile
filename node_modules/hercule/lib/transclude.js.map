{"version":3,"sources":["../src/transclude.js"],"names":["Transclude","SYNTAX","hercule","REGEXP","MATCH_GROUP","INDENT_GROUP","LINK_GROUP","aglio","marked","multimarkdown","shiftCursor","content","line","column","newLines","match","length","newColumns","newLine","newColumn","applyReferences","chunk","source","transclusionLink","link","inheritedReferences","references","contentLink","scopeReferences","descendantReferences","contextReferences","find","placeholder","url","nextReferences","uniqBy","options","transclusionSyntax","inheritedParents","inheritedIndent","resolvers","pattern","inputBuffer","transclude","cb","self","process","nextTick","push","parents","indent","sourceLine","sourceColumn","out","error","message","path","contentStream","resolvedUrl","includes","resolvedSource","resolvedParents","undefined","nestedTransclude","on","inputReadable","streamContent","read","err","pipe","toToken","output","lastIndexOf","toSeparators","separator","separators","map","without","tokenize","lastChunk","nextOffset","tokens","exec","index","slice","concat","lastIndex","transform","encoding","isPlainObject","eachSeries","toString","next","call","flush","obj"],"mappings":"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","file":"transclude.js","sourcesContent":["import through2 from 'through2';\nimport _ from 'lodash';\nimport async from 'async';\nimport cloneRegExp from 'clone-regexp';\nimport leftsplit from 'left-split';\n\nimport { resolveToReadableStream } from './resolver';\nimport { parseContent } from './parse';\n\nconst SYNTAX = {\n  hercule: {\n    REGEXP: /(^[\\t ]*)?:\\[.*?]\\((.*?)\\)/gm,\n    MATCH_GROUP: 0,\n    INDENT_GROUP: 1,\n    LINK_GROUP: 2,\n  },\n  aglio: {\n    REGEXP: /( *)?(<!-- include\\((.*?)\\) -->)/gmi,\n    MATCH_GROUP: 0,\n    INDENT_GROUP: 1,\n    LINK_GROUP: 3,\n  },\n  marked: {\n    REGEXP: /( *)?<<\\[(.*)]/gm,\n    MATCH_GROUP: 0,\n    INDENT_GROUP: 1,\n    LINK_GROUP: 2,\n  },\n  multimarkdown: {\n    REGEXP: /( *)?{{(.*)}}/gm,\n    MATCH_GROUP: 0,\n    INDENT_GROUP: 1,\n    LINK_GROUP: 2,\n  },\n};\n\nfunction shiftCursor(content, { line, column }) {\n  const newLines = (content.match(/\\n/g) || []).length;\n  const newColumns = content.match(/.*$/g)[0].length;\n\n  const newLine = line + newLines;\n  const newColumn = (newLines > 0) ? newColumns : column + newColumns;\n\n  return { line: newLine, column: newColumn };\n}\n\nfunction applyReferences(chunk) {\n  const { source, line, column } = chunk;\n  const transclusionLink = chunk.link;\n  const inheritedReferences = chunk.references;\n\n  const { contentLink, scopeReferences, descendantReferences } =\n    parseContent(transclusionLink, { source, line, column });\n\n  // Inherited reference take precendence over fallback reference\n  const contextReferences = [...inheritedReferences, ...scopeReferences];\n  const link = _.find(contextReferences, { placeholder: contentLink.url }) || contentLink;\n\n  // Prefer nearest inherited reference\n  const nextReferences = _.uniqBy([...descendantReferences, ...inheritedReferences], 'placeholder');\n\n  return { link, nextReferences };\n}\n\nexport default function Transclude(source = 'string', options = {}) {\n  const {\n    transclusionSyntax = 'hercule',\n    inheritedParents = [],\n    inheritedReferences = [],\n    inheritedIndent = '',\n    resolvers,\n  } = options;\n  const { REGEXP, MATCH_GROUP, INDENT_GROUP, LINK_GROUP } = SYNTAX[transclusionSyntax];\n  const pattern = cloneRegExp(REGEXP);\n  let inputBuffer = '';\n  let line = 1;\n  let column = 0;\n\n  function transclude(chunk, cb) {\n    const self = this;\n\n    // eslint-disable-next-line consistent-return\n    process.nextTick(() => {\n      if (!chunk.link) {\n        self.push(chunk);\n        return cb();\n      }\n\n      const { parents, indent } = chunk;\n      const sourceLine = chunk.line;\n      const sourceColumn = chunk.column;\n      const content = chunk.content;\n\n      let out;\n      try {\n        out = applyReferences(chunk);\n      } catch (error) {\n        self.push(chunk.link);\n        return cb({ message: 'Link could not be parsed', path: source, error, line: sourceLine, column: sourceColumn });\n      }\n\n      const { link, nextReferences } = out;\n      link.content = content;\n\n      const { contentStream, resolvedUrl } = resolveToReadableStream(link, resolvers);\n      if (_.includes(parents, resolvedUrl)) {\n        self.push(link);\n        return cb({ message: 'Circular dependency detected', path: resolvedUrl, line: link.line, column: link.column });\n      }\n\n      // Resolved URL will be undefined for quoted strings: :[exmple](link || \"fallback\" reference:\"string\")\n      const resolvedSource = resolvedUrl || link.source;\n      const resolvedParents = resolvedSource ? parents : undefined;\n\n      const nestedTransclude = new Transclude(resolvedSource, {\n        transclusionSyntax,\n        inheritedParents: resolvedParents,\n        inheritedReferences: nextReferences,\n        inheritedIndent: indent,\n        resolvers,\n      });\n\n      nestedTransclude\n        .on('readable', function inputReadable() {\n          let streamContent;\n          while ((streamContent = this.read()) !== null) {\n            self.push(streamContent);\n          }\n        })\n        .on('error', err => cb(err))\n        .on('end', () => cb(null, true));\n      contentStream.on('error', err => cb(err));\n      contentStream.pipe(nestedTransclude);\n    });\n  }\n\n  function toToken(chunk) {\n    const content = chunk[MATCH_GROUP];\n    const link = chunk[LINK_GROUP];\n    const indent = chunk[INDENT_GROUP] || '';\n\n    const output = { content, line, column };\n    output.link = link;\n    output.source = source;\n    output.parents = [...inheritedParents, source];\n    output.references = [...inheritedReferences];\n    output.indent = inheritedIndent + indent;\n    output.column += content.lastIndexOf(link);\n\n    ({ line, column } = shiftCursor(content, { line, column }));\n\n    return output;\n  }\n\n  function toSeparators(separator) {\n    // Each line must be processed individually for correct sourcemap output\n    let separators = leftsplit(separator, /(\\r?\\n)/);\n\n    separators = _.map(separators, (content) => {\n      if (!content) return null;\n\n      const output = { content, line, column };\n      output.source = source;\n      output.indent = inheritedIndent;\n      output.parents = [...inheritedParents];\n\n      ({ line, column } = shiftCursor(content, { line, column }));\n\n      return output;\n    });\n\n    return _.without(separators, null);\n  }\n\n  function tokenize(chunk) {\n    const lastChunk = !chunk;\n    let nextOffset = 0;\n    let match = null;\n    let tokens = [];\n\n    if (chunk) inputBuffer += chunk;\n\n    while ((match = pattern.exec(inputBuffer)) !== null) {\n      // Content prior to match can be returned without transform\n      if (match.index > nextOffset) {\n        const separator = inputBuffer.slice(nextOffset, match.index);\n        tokens = tokens.concat(toSeparators(separator));\n      }\n\n      // Match within bounds: [  xxxx  ]\n      if (pattern.lastIndex < inputBuffer.length || lastChunk) {\n        tokens.push(toToken(match));\n\n        // Next match must be after this match\n        nextOffset = pattern.lastIndex;\n      // Match against bounds: [     xxx]\n      } else {\n        // Next match will be the start of this match\n        nextOffset = match.index;\n      }\n    }\n\n    inputBuffer = inputBuffer.slice(nextOffset);\n    pattern.lastIndex = 0;\n\n    // End of input, flush the input buffer\n    if (lastChunk) tokens = tokens.concat(toSeparators(inputBuffer));\n\n    return tokens;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function transform(chunk, encoding, cb) {\n    // Allow objects straight through\n    if (_.isPlainObject(chunk)) return cb(null, chunk);\n\n    async.eachSeries(\n      tokenize(chunk.toString('utf8')),\n      (output, next) => transclude.call(this, output, next),\n      (err) => {\n        if (err) inputBuffer = '';\n        cb(err);\n      });\n  }\n\n  function flush(cb) {\n    async.eachSeries(\n      tokenize(),\n      (output, next) => transclude.call(this, output, next),\n      (err) => {\n        this.push(null);\n        cb(err);\n      });\n  }\n\n  return through2.obj(transform, flush);\n}\n"]}