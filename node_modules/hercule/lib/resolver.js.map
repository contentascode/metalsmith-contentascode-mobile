{"version":3,"sources":["../src/resolver.js"],"names":["resolveHttpUrl","resolveLocalUrl","resolveString","resolveToReadableStream","url","isHttpUrl","test","content","stream","on","error","res","statusCode","emit","message","path","sourcePath","isLocalUrl","relativePath","dirname","localUrl","join","createReadStream","encoding","input","isQuotedString","slice","defaultResolvers","link","resolvers","reduce","memo","resolver","source","outputStream","isString","objectMode","push","line","column","Error","contentStream","resolvedUrl"],"mappings":";;;;;QAOgBA,c,GAAAA,c;QAeAC,e,GAAAA,e;QAYAC,a,GAAAA,a;QAaAC,uB,GAAAA,uB;;AA/ChB;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;AACA;;;;;;AAEO,SAASH,cAAT,CAAwBI,GAAxB,EAA6B;AAClC;AACA,MAAMC,YAAY,cAAlB;AACA,MAAI,CAACA,UAAUC,IAAV,CAAeF,GAAf,CAAL,EAA0B,OAAO,IAAP;;AAE1B,MAAMG,UAAU,cAAIC,MAAJ,CAAWJ,GAAX,CAAhB;;AAEA;AACAG,UAAQE,EAAR,CAAW,UAAX,EAAuB,SAASC,KAAT,CAAeC,GAAf,EAAoB;AACzC,QAAIA,IAAIC,UAAJ,KAAmB,GAAvB,EAA4B,KAAKC,IAAL,CAAU,OAAV,EAAmB,EAAEC,SAAS,qBAAX,EAAkCC,MAAMX,GAAxC,EAAnB;AAC7B,GAFD;;AAIA,SAAO,EAAEG,gBAAF,EAAWH,QAAX,EAAP;AACD;;AAEM,SAASH,eAAT,CAAyBG,GAAzB,EAA8BY,UAA9B,EAA0C;AAC/C,MAAMC,aAAa,YAAnB;AACA,MAAI,CAACA,WAAWX,IAAX,CAAgBF,GAAhB,CAAL,EAA2B,OAAO,IAAP;;AAE3B,MAAMc,eAAe,eAAKC,OAAL,CAAaH,UAAb,CAArB;AACA,MAAMI,WAAW,eAAKC,IAAL,CAAUH,YAAV,EAAwBd,GAAxB,CAAjB;;AAEA,MAAMG,UAAU,aAAGe,gBAAH,CAAoBF,QAApB,EAA8B,EAAEG,UAAU,MAAZ,EAA9B,CAAhB;;AAEA,SAAO,EAAEhB,gBAAF,EAAWH,KAAKgB,QAAhB,EAAP;AACD;;AAEM,SAASlB,aAAT,CAAuBsB,KAAvB,EAA8B;AACnC,MAAMC,iBAAiB,cAAvB;AACA,MAAI,CAACA,eAAenB,IAAf,CAAoBkB,KAApB,CAAL,EAAiC,OAAO,IAAP;;AAEjC,SAAO,EAAEjB,SAASiB,MAAME,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAAX,EAAP;AACD;;AAED,IAAMC,mBAAmB,CAAC3B,cAAD,EAAiBC,eAAjB,EAAkCC,aAAlC,CAAzB;;AAEA;AACA;AACA;AACA;AACO,SAASC,uBAAT,CAAiCyB,IAAjC,EAAqE;AAAA,MAA9BC,SAA8B,uEAAlBF,gBAAkB;;AAAA,iBACjD,iBAAEG,MAAF,CAASD,SAAT,EACvB,UAACE,IAAD,EAAOC,QAAP;AAAA,WAAoBD,QAAQC,SAASJ,KAAKxB,GAAd,EAAmBwB,KAAKK,MAAxB,CAA5B;AAAA,GADuB,EAEvB,IAFuB,CADiD;AAAA,MAClE1B,OADkE,YAClEA,OADkE;AAAA,MACzDH,GADyD,YACzDA,GADyD;;AAK1E,MAAI8B,qBAAJ;;AAEA,MAAI,iBAAEC,QAAF,CAAW5B,OAAX,CAAJ,EAAyB;AACvB2B,mBAAe,uBAAS,EAAEE,YAAY,IAAd,EAAT,CAAf;;AAEAF,iBAAaG,IAAb,CAAkB;AAChB9B,sBADgB;AAEhB0B,cAAQL,KAAKK,MAFG;AAGhBK,YAAMV,KAAKU,IAHK;AAIhBC,cAAQX,KAAKW;AAJG,KAAlB;AAMAL,iBAAaG,IAAb,CAAkB,IAAlB;AACD,GAVD,MAUO,IAAI,0BAAW9B,OAAX,CAAJ,EAAyB;AAC9B2B,mBAAe3B,OAAf;AACD,GAFM,MAEA;AACL,UAAM,IAAIiC,KAAJ,8CAAoDZ,KAAKxB,GAAzD,QAAN;AACD;;AAED,SAAO,EAAEqC,eAAeP,YAAjB,EAA+BQ,aAAatC,GAA5C,EAAP;AACD","file":"resolver.js","sourcesContent":["import _ from 'lodash';\nimport fs from 'fs';\nimport path from 'path';\nimport got from 'got';\nimport { isReadable } from 'isstream';\nimport through2 from 'through2';\n\nexport function resolveHttpUrl(url) {\n  // TODO: handle relative link in\n  const isHttpUrl = /^https?:\\/\\//;\n  if (!isHttpUrl.test(url)) return null;\n\n  const content = got.stream(url);\n\n  // Manually trigger error since 2XX respsonse doesn't trigger error despite not having expected content\n  content.on('response', function error(res) {\n    if (res.statusCode !== 200) this.emit('error', { message: 'Could not read file', path: url });\n  });\n\n  return { content, url };\n}\n\nexport function resolveLocalUrl(url, sourcePath) {\n  const isLocalUrl = /^[^ ()\"']+/;\n  if (!isLocalUrl.test(url)) return null;\n\n  const relativePath = path.dirname(sourcePath);\n  const localUrl = path.join(relativePath, url);\n\n  const content = fs.createReadStream(localUrl, { encoding: 'utf8' });\n\n  return { content, url: localUrl };\n}\n\nexport function resolveString(input) {\n  const isQuotedString = /^[\"'].*[\"']$/;\n  if (!isQuotedString.test(input)) return null;\n\n  return { content: input.slice(1, -1) };\n}\n\nconst defaultResolvers = [resolveHttpUrl, resolveLocalUrl, resolveString];\n\n// Resolves link to string or stream\n//  - resolvers is an array of synchronus functions that return null, string or stream.\n//  - stream requires processing\n//  - string assumed fully processed\nexport function resolveToReadableStream(link, resolvers = defaultResolvers) {\n  const { content, url } = _.reduce(resolvers,\n    (memo, resolver) => memo || resolver(link.url, link.source),\n    null);\n\n  let outputStream;\n\n  if (_.isString(content)) {\n    outputStream = through2({ objectMode: true });\n\n    outputStream.push({\n      content,\n      source: link.source,\n      line: link.line,\n      column: link.column,\n    });\n    outputStream.push(null);\n  } else if (isReadable(content)) {\n    outputStream = content;\n  } else {\n    throw new Error(`no readable stream or string, resolve '${link.url}'`);\n  }\n\n  return { contentStream: outputStream, resolvedUrl: url };\n}\n"]}